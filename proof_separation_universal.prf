
  Definition separated_equiv_Δ : forall (P : Trunc (trunc_S n)) (Q :{T : Trunc (trunc_S n) & separated T}),
                                 IsEquiv (fun f : separated_Type P -> pr1 (pr1 Q) =>
                                           f o (separated_unit P)).
    intros P Q.
    apply isequiv_adjointify with (g := sep_eq_inv_Δ Q).
    - intro φ.
     apply path_forall; intro x.
      unfold sep_eq_inv_Δ, separated_unit, compose.
      unfold equiv_inv.
      destruct (separated_unit_coeq_Δ P (Q .1) .1) as [inv1 retr1 sect1 _].

      specialize (retr1 (φ;
     (let (Q0, sepQ) as s
          return
            (∀ f : P .1 → (s .1) .1,
             (λ x0 : (clΔ P) .1, f (fst x0 .1)) =
             (λ x0 : (clΔ P) .1, f (snd x0 .1))) := Q in
      λ f : P .1 → ((Q0; sepQ) .1) .1,
      match
        sepQ (clΔ P) .1 (dense_into_cloture (δ P))
          (λ X : ∃ b : P .1 ∧ P .1,
                 ((O nj (fst b = snd b; istrunc_paths P .2 (fst b) (snd b)))
                  .1) .1, f (fst X .1))
          (λ X : ∃ b : P .1 ∧ P .1,
                 ((O nj (fst b = snd b; istrunc_paths P .2 (fst b) (snd b)))
                  .1) .1, f (snd X .1))
      with
      | {| equiv_inv := inv |} =>
          path_forall (λ x0 : ∃ b : P .1 ∧ P .1, (clδ P b) .1, f (fst x0 .1))
            (λ x0 : ∃ b : P .1 ∧ P .1, (clδ P b) .1, f (snd x0 .1))
            (λ x0 : ∃ b : P .1 ∧ P .1, (clδ P b) .1,
             ap10
               (inv
                  (path_forall
                     (λ x1 : ∃ (b : ∃ b : P .1 ∧ P .1,
                                    ((O nj
                                        (fst b = snd b;
                                        istrunc_paths P .2 (fst b) (snd b)))
                                     .1) .1) (π : fst b .1 = snd b .1),
                             b .2 =
                             O_unit nj
                               (fst b .1 = snd b .1;
                               istrunc_paths P .2 (fst b .1) (snd b .1)) π,
                      f (fst (x1 .1) .1))
                     (λ x1 : ∃ (b : ∃ b : P .1 ∧ P .1,
                                    ((O nj
                                        (fst b = snd b;
                                        istrunc_paths P .2 (fst b) (snd b)))
                                     .1) .1) (π : fst b .1 = snd b .1),
                             b .2 =
                             O_unit nj
                               (fst b .1 = snd b .1;
                               istrunc_paths P .2 (fst b .1) (snd b .1)) π,
                      f (snd (x1 .1) .1))
                     (λ x1 : ∃ (b : ∃ b : P .1 ∧ P .1,
                                    ((O nj
                                        (fst b = snd b;
                                        istrunc_paths P .2 (fst b) (snd b)))
                                     .1) .1) (π : fst b .1 = snd b .1),
                             b .2 =
                             O_unit nj
                               (fst b .1 = snd b .1;
                               istrunc_paths P .2 (fst b .1) (snd b .1)) π,
                      ap f (x1 .2) .1))) x0)
      end) φ)).
      (* simpl in retr1. clear sect1. *)

      pose (foo := ap10 (retr1..1) x).
      exact foo.
    - intro φ.
      (* apply path_forall; intro x. *)
      unfold sep_eq_inv_Δ, separated_unit, compose.

      apply (@equiv_inj _ _ _ (separated_unit_coeq_Δ P (Q .1) .1)).

      pose (foo := (eisretr _ (IsEquiv := (separated_unit_coeq_Δ P (Q .1) .1))) (λ x : P .1,
       φ (toIm (λ t t' : P .1, O nj (t = t'; istrunc_paths P .2 t t')) x);
      (let (Q0, sepQ) as s
           return
             (∀ f : P .1 → (s .1) .1,
              (λ x : (clΔ P) .1, f (fst x .1)) =
              (λ x : (clΔ P) .1, f (snd x .1))) := Q in
       λ f : P .1 → ((Q0; sepQ) .1) .1,
       match
         sepQ (clΔ P) .1 (dense_into_cloture (δ P))
           (λ X : ∃ b : P .1 ∧ P .1,
                  ((O nj (fst b = snd b; istrunc_paths P .2 (fst b) (snd b)))
                   .1) .1, f (fst X .1))
           (λ X : ∃ b : P .1 ∧ P .1,
                  ((O nj (fst b = snd b; istrunc_paths P .2 (fst b) (snd b)))
                   .1) .1, f (snd X .1))
       with
       | {| equiv_inv := inv |} =>
           path_forall (λ x : ∃ b : P .1 ∧ P .1, (clδ P b) .1, f (fst x .1))
             (λ x : ∃ b : P .1 ∧ P .1, (clδ P b) .1, f (snd x .1))
             (λ x : ∃ b : P .1 ∧ P .1, (clδ P b) .1,
              ap10
                (inv
                   (path_forall
                      (λ x0 : ∃ (b : ∃ b : P .1 ∧ P .1,
                                     ((O nj
                                         (fst b = snd b;
                                         istrunc_paths P .2 (fst b) (snd b)))
                                      .1) .1) (π : fst b .1 = snd b .1),
                              b .2 =
                              O_unit nj
                                (fst b .1 = snd b .1;
                                istrunc_paths P .2 (fst b .1) (snd b .1)) π,
                       f (fst (x0 .1) .1))
                      (λ x0 : ∃ (b : ∃ b : P .1 ∧ P .1,
                                     ((O nj
                                         (fst b = snd b;
                                         istrunc_paths P .2 (fst b) (snd b)))
                                      .1) .1) (π : fst b .1 = snd b .1),
                              b .2 =
                              O_unit nj
                                (fst b .1 = snd b .1;
                                istrunc_paths P .2 (fst b .1) (snd b .1)) π,
                       f (snd (x0 .1) .1))
                      (λ x0 : ∃ (b : ∃ b : P .1 ∧ P .1,
                                     ((O nj
                                         (fst b = snd b;
                                         istrunc_paths P .2 (fst b) (snd b)))
                                      .1) .1) (π : fst b .1 = snd b .1),
                              b .2 =
                              O_unit nj
                                (fst b .1 = snd b .1;
                                istrunc_paths P .2 (fst b .1) (snd b .1)) π,
                       ap f (x0 .2) .1))) x)
       end)
        (λ x : P .1,
         φ (toIm (λ t t' : P .1, O nj (t = t'; istrunc_paths P .2 t t')) x)))).
      (* simpl in foo. *)

      apply (transport (λ u, u = (φ o (separated_unit P; separated_unit_coeq_Δ_coeq P) .1;
   ap (λ u : (clΔ P) .1 → separated_Type P, φ o u)
     (separated_unit P; separated_unit_coeq_Δ_coeq P) .2)) foo^).
      clear foo.

      unfold separated_unit, compose.

      apply path_sigma' with (p:=1). rewrite transport_1.

      destruct Q as [Q sepQ]. 

      destruct ( sepQ (clΔ P) .1 (dense_into_cloture (δ P))
       (λ X : ∃ b : P .1 ∧ P .1,
              ((O nj (fst b = snd b; istrunc_paths P .2 (fst b) (snd b))) .1)
              .1,
        φ
          (toIm (λ t t' : P .1, O nj (t = t'; istrunc_paths P .2 t t'))
             (fst X .1)))
       (λ X : ∃ b : P .1 ∧ P .1,
              ((O nj (fst b = snd b; istrunc_paths P .2 (fst b) (snd b))) .1)
              .1,
        φ
          (toIm (λ t t' : P .1, O nj (t = t'; istrunc_paths P .2 t t'))
             (snd X .1)))) as [inv retr sect _].

      apply (@equiv_inj _ _ _ (isequiv_ap10 _ _)).
      unfold ap10 at 1, path_forall at 1.
      rewrite eisretr.

      apply path_forall; intro x.
      
      set (eqq := (path_forall
           (λ x0 : ∃ (b : ∃ b : P .1 ∧ P .1,
                          ((O nj
                              (fst b = snd b;
                              istrunc_paths P .2 (fst b) (snd b))) .1) .1)
                   (π : fst b .1 = snd b .1),
                   b .2 =
                   O_unit nj
                     (fst b .1 = snd b .1;
                     istrunc_paths P .2 (fst b .1) (snd b .1)) π,
            φ
              (toIm (λ t t' : P .1, O nj (t = t'; istrunc_paths P .2 t t'))
                 (fst (x0 .1) .1)))
           (λ x0 : ∃ (b : ∃ b : P .1 ∧ P .1,
                          ((O nj
                              (fst b = snd b;
                              istrunc_paths P .2 (fst b) (snd b))) .1) .1)
                   (π : fst b .1 = snd b .1),
                   b .2 =
                   O_unit nj
                     (fst b .1 = snd b .1;
                     istrunc_paths P .2 (fst b .1) (snd b .1)) π,
            φ
              (toIm (λ t t' : P .1, O nj (t = t'; istrunc_paths P .2 t t'))
                 (snd (x0 .1) .1)))
           (λ x0 : ∃ (b : ∃ b : P .1 ∧ P .1,
                          ((O nj
                              (fst b = snd b;
                              istrunc_paths P .2 (fst b) (snd b))) .1) .1)
                   (π : fst b .1 = snd b .1),
                   b .2 =
                   O_unit nj
                     (fst b .1 = snd b .1;
                     istrunc_paths P .2 (fst b .1) (snd b .1)) π,
            ap
              (λ x1 : P .1,
               φ
                 (toIm
                    (λ t t' : P .1, O nj (t = t'; istrunc_paths P .2 t t'))
                    x1)) (x0 .2) .1))).

      apply (ap (λ u, ap10 u x) (x:=(inv eqq)) (y:=(ap (λ (u : (clΔ P) .1 → separated_Type P) (x0 : (clΔ P) .1), φ (u x0))
        (toIm (λ t t' : P .1, O nj (t = t'; istrunc_paths P .2 t t'));
        separated_unit_coeq_Δ_coeq P) .2)) ).

      specialize (sect (ap (λ (u : (clΔ P) .1 → separated_Type P) (x0 : (clΔ P) .1), φ (u x0)) (separated_unit_coeq_Δ_coeq P))).
      apply (transport (λ u, inv eqq = u) sect).
      apply ap.
      unfold eqq. unfold E_to_χ_map. clear eqq.
      apply (@equiv_inj _ _ _ (isequiv_ap10 _ _)).
      unfold ap10 at 1, path_forall at 1. rewrite eisretr.
      apply path_forall.
      intro y.

      unfold clΔ, clδ, δ, compose. 

      pose (foo := ap_ap10_L (λ x0 : (nchar_to_sub
             (λ x0 : P .1 ∧ P .1,
              (O nj (fst x0 = snd x0; istrunc_paths P .2 (fst x0) (snd x0)))
              .1)) .1,
   φ ((separated_unit P o (λ x : (clΔ P) .1, fst x .1)) x0)) (λ x0 : (nchar_to_sub
             (λ x0 : P .1 ∧ P .1,
              (O nj (fst x0 = snd x0; istrunc_paths P .2 (fst x0) (snd x0)))
              .1)) .1,
   φ ((separated_unit P o (λ x : (clΔ P) .1, snd x .1)) x0)) (λ (x0 : ∃ b : (nchar_to_sub
                        (λ x0 : P .1 ∧ P .1,
                         (O nj
                            (fst x0 = snd x0;
                            istrunc_paths P .2 (fst x0) (snd x0))) .1)) .1,
               ((dense_into_cloture
                   (λ x0 : P .1 ∧ P .1,
                    (fst x0 = snd x0; istrunc_paths P .2 (fst x0) (snd x0))))
                  b) .1), x0.1) (ap
           (λ (u : (nchar_to_sub
                      (λ x0 : P .1 ∧ P .1,
                       (O nj
                          (fst x0 = snd x0;
                          istrunc_paths P .2 (fst x0) (snd x0))) .1)) .1
                   → separated_Type P)
            (x0 : (nchar_to_sub
                     (λ x0 : P .1 ∧ P .1,
                      (O nj
                         (fst x0 = snd x0;
                         istrunc_paths P .2 (fst x0) (snd x0))) .1)) .1),
            φ (u x0)) (separated_unit_coeq_Δ_coeq P)) y).
      unfold clΔ, clδ, δ, compose in foo.

      apply (transport (λ U, _ = U) foo^). clear foo.

      destruct y as [[(a,b) t] r].
      unfold clδ, δ, compose in t; simpl in t.
      unfold dense_into_cloture, δ, compose in r. simpl in r.
      destruct r as [π r].
      destruct π.
      simpl.
      
      
      pose (foo := ap_ap10 (separated_unit P o (λ x : (clΔ P) .1, fst x .1)) (separated_unit P o (λ x : (clΔ P) .1, snd x .1)) φ (separated_unit_coeq_Δ_coeq P) ((a,a);t)).
      unfold clΔ, clδ, δ, compose in foo.
      unfold compose.
      apply (transport (λ U, _ = U) foo). clear foo.
      unfold separated_unit_coeq_Δ_coeq.
      unfold ap10 at 1, path_forall at 1.
      rewrite (eisretr apD10).

      path_via (ap φ (idpath (separated_unit P a))).

      apply (ap (λ u, ap φ u)).
      symmetry.

      assert (((ap pr1 (retr_kpsic_inv ((a, a); t)))) = 1).
      Focus 1.
      unfold retr_kpsic_inv.
      unfold path_sigma' at 1.
      apply projT1_path_sigma.

      path_via ( 
          ((let (a0, s) as s
                return
                (separated_unit P (fst (kpsic_inv s) .1) =
                 separated_unit P (snd (kpsic_inv s) .1)) :=
                kpsic_func ((a, a); t) in
            let (b, p) as s0
                return
                (separated_unit P (fst (kpsic_inv (a0; s0)) .1) =
                 separated_unit P (snd (kpsic_inv (a0; s0)) .1)) := s in
            p))).

     Focus 2.

     unfold kpsic_func.

     apply (@equiv_inj _ _ _ ( subset_is_subobject
          (λ a0 : (P .1 → subuniverse_Type nj; T_nType_j_Type_trunc P) .1,
           istrunc_truncation minus_one
             (hfiber
                (λ t0 t' : P .1, O nj (t0 = t'; istrunc_paths P .2 t0 t')) a0))
          (separated_unit P a) (separated_unit P a))).
     rewrite eisretr.

     apply (@equiv_inj _ _ _ (isequiv_ap10 _ _)).
     unfold ap10 at 1, path_forall at 1; rewrite eisretr.

     simpl. apply path_forall; intro u. simpl.

     apply (@equiv_inj _ _ (equiv_inv (IsEquiv := isequiv_unique_subuniverse _ _))).
       apply isequiv_inverse.
     rewrite eissect.

     apply (@equiv_inj _ _ (equiv_inv (IsEquiv := isequiv_truncn_unique _ _))).
       apply isequiv_inverse.
     rewrite eissect.

     simpl.

     apply (@equiv_inj _ _ _ (isequiv_equiv_path _ _)).
     unfold univalence_axiom.
     rewrite eisretr. simpl. unfold equiv_path.

     apply equal_equiv. unfold kpsic_func_univ_func. simpl.
     apply (@equiv_inj _ _ _ (O_equiv nj _ _)).
     rewrite O_rec_retr.

     apply path_forall; intro v. unfold compose; simpl.
     unfold δ. simpl.
     rewrite r.

     pose (foo := ap10 (O_rec_retr (a = a; istrunc_paths P .2 a a) (O nj (a = u; istrunc_paths P .2 a u)) (λ v0 : a = a, O_unit nj (a = u; istrunc_paths P .2 a u) (v0 ^ @ v))) 1). unfold compose in foo. simpl in foo.
     etransitivity. exact foo.
     apply ap.
     rewrite concat_1p. exact 1.

     assert (ap (separated_unit P) (ap snd (ap pr1 (retr_kpsic_inv ((a, a); t)))) = 1).
     rewrite X. auto.

     assert (ap (separated_unit P) (ap fst (ap pr1 (retr_kpsic_inv ((a, a); t)) ^)) = 1).
     path_via (ap (separated_unit P) (idpath a)).
       apply ap.
     path_via (ap fst (idpath (a,a))).
       apply ap.

     rewrite ap_V.
     apply (transport (λ u, u^=1) X^). auto.

     assert (forall (A:Type) (a:A) (p q:a=a) (Hp : p=1) (Hq : q=1) r, p @ (r @ q) = r).
       intros A a0 p q Hp Hq r0.
       rewrite Hp. rewrite Hq. rewrite concat_1p. apply concat_p1.

     apply X2.
     exact X1. exact X0.
  Qed.